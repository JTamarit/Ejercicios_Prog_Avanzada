<meta charset="utf-8">
**02EPPY - 104 - Game y Frames**
    <small>©2021 VIU - 02EPPY Programación Avanzada - Iván Fuertes</small>

Clase Game
==============================================================

Para empezar a organizar el código se va a empezar por crear una clase *Game*, que va a ser la raíz donde va a arrancar todo el código. En lugar de tenerlo todo en una función única, se va a mover el código de una manera más estructurada. Se puede extraer funcionalidad separada en diferentes funciones, y usarlas dentro de la clase *Game*. En el ejemplo del capítulo anterior se tenían tres áreas muy diferenciadas, inicialización, procesado de eventos y pintado. Si se continuara desarrollando, estas tres partes crecerían bastante, y se acabaría con una pared gigante de código, casi imposible de navegar. Estructurarlo en la clase *Game* ayudará a eso.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Python
class Game:
    def __init__(self):
        pass

    def run(self):
        pass

    def __process_events(self):
        pass

    def __update(self):
        pass

    def __render(self):
        pass

    def __quit(self):
        pass
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [game_proto]: Prototipo de la Clase *Game*]

El único método público de la clase es *run*, que es el punto de entrada desde el cual el *`__main__.py`* llama a la clase una vez creada la instancia. Se puede mover el código de inicialización al constructor de la clase, el *main loop* se mantiene en la función *run*, pero esta llama a *process_events*, *update* y *render* para mantener esas tres funcionalidades separadas. Y por último al acabar el *main loop* se llama a *quit* para liberar recursos.

Constructor
--------------------------------------------------------------

Como miembros estáticos privados de la clase se ha puesto el tamaño de la ventana *screen_size*, el título del juego *game_title* y la ruta a la imagén del jugador *hero_image_filename*.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Python
__screen_size = (640, 480)
__game_title = "ShMUp"
__hero_image_filename = ["shmup", "assets", "images", "hero.png"]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [static_members]: Miembros Estáticos Privados de la Clase *Game*]

En el constructor *'__init__'* se inicia PyGame llamando a *pygame.init()*, se crea la ventana y se le pone nombre como se ha visto anteriormente, y se carga la imagen para el jugador en una *surface*.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Python
def __init__(self):
    pygame.init()

    self.__window = pygame.display.set_mode(Game.__screen_size, 0, 32)
    pygame.display.set_caption(Game.__game_title)

    self.__hero = pygame.image.load(os.path.join(*Game.__hero_image_filename)).convert_alpha()

    self.__running = False
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [init_game]: Constructor de la Clase *Game*]

Run
--------------------------------------------------------------

En la función *run* que va a hacer de punto de arranque del juego se controla el *main loop*, el bucle infinito que estará siempre en ejecución. Dentro del *main loop* llamará primero a *process_events* para gestionar la cola de eventos, luego a *update* para actualizar el estado del juego, y por último a *render* para pintar un nuevo frame con los cambios realizados. Al salir del *loop* se llama a *quit* para liberar los recursos que se hayan podido adquirir.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Python
def run(self):
    self.__running = True

    while self.__running:
        self.__process_events()
        self.__update()
        self.__render()

    self.__quit()
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [run_game]: Método *run* de la Clase *Game*]

Event Loop
--------------------------------------------------------------

En la función *process_events* se va a gestionar la cola de eventos de PyGame, de la manera vista anteriormente, por ahora sólo la opción de cerrar el juego.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Python
def __process_events(self):
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            self.__running = False
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [process_events_game]: Método *process_events* de la Clase *Game*]

Update
--------------------------------------------------------------

La función *update* por ahora está vacía puesto que aún no se ha implementado nada de lógica de juego.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Python
def __update(self):
    pass
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [update_game]: Método *update* de la Clase *Game*]

Render
--------------------------------------------------------------

La función *render* es la que se encarga de pintar todo el mundo virtual a pantalla. El resultado del pintado del frame anterior se descarta, y por tanto lo primero que se hace es limpiar la pantalla. A continuación se pintan todos los objetos del juego, y a continuación se actualiza la pantalla para mostrarla en el monitor.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Python
def __render(self):
    self.__window.fill((0, 0, 0))

    x, y = pygame.mouse.get_pos()
    x -= self.__hero.get_width() / 2
    y -= self.__hero.get_height() / 2
    self.__window.blit(self.__hero_image, (x, y))

    pygame.display.update()
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [render_game]: Método *render* de la Clase *Game*]

Quit
--------------------------------------------------------------

Por último, el método *quit* se encargará de liberar cualquier recurso que el juego haya adquirido y no vaya a ser necesario. En este caso, simplemente comunicará a PyGame que su trabajo ha terminado.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Python
def __quit(self):
    pygame.quit()
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [quit_game]: Método *quit* de la Clase *Game*]

Frame Rate
==============================================================

Profundizando un poco más dentro el *main loop* que está dentro del método *run*, este es el que controla el ciclo de vida del juego. Mientras éste continue iterando, el juego seguirá vivo.

Lo que se hace en cada iteración del loop es, primero procesar los eventos de PyGame, luego actualizar el juego, y por último pintar los resultados a pantalla. A cada iteración del *game loop* se le suele llamar *frame* o *tick*. La medida de cuantas iteraciones del *game loop* se pueden realizar por segundo son los *FPS*, *Frames Per Second* o frames por segundo. A veces, el concepto de *FPS* solo tiene en cuenta tiempos de pintado, pero es común que englobe el tiempo de procesamiento de las entradas y de las actualizaciones de la lógica de juego.

![Figure [res/104_000]: Ciclo de Vida de un Juego](res/104_000.png)

El diagrama Figure [res/005_000] describe perfectamente lo que hace el juego en cada momento. Todo lo que se hace dentro del juego es bastante lineal, todo se ejecuta en el orden que se le dice y la maquina no hace nada que no se le haya pedido explícitamente.

Procesamiento de Eventos a través de los Frames
--------------------------------------------------------------

Por cada iteración del *loop* de eventos puede llegar un evento distinto, pero al juego que se está desarrollando le interesan sobre todo las pulsaciones de tecla para gestionar la entrada del jugador. Así que se va a delegar ese trabajo a una función específica que pueda gestionar esas pulsaciones y relacionarlas con acciones del jugador.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Python
def __process_events(self):
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            self.__running = False
        if event.type == pygame.KEYDOWN:
            self.__handle_player_input(event.key, True)
        elif event.type == pygame.KEYUP:
            self.__handle_player_input(event.key, False)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [process_events]: Método *process_events* Delegando Pulsaciones de Tecla]

Con este método ahora se delega a otra función la gestión espécifica de los eventos de pulsaciones de teclado.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Python
def __handle_player_input(self, key, is_pressed):
    if key == K_UP:
        self.__is_moving_up = is_pressed
    elif key == K_DOWN:
        self.__is_moving_down = is_pressed
    elif key == K_LEFT:
        self.__is_moving_left = is_pressed
    elif key == K_RIGHT:
        self.__is_moving_right = is_pressed
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [handle_player_input]: Método *handle_player_input*]

Esta función activa/desactiva unos flags que indican en que dirección se mueve el jugador.Responde a las pulsaciones de las teclas de cursor para indicar hacia donde debe moverse. Estos flags deben inicializarse en el constructor a *False*.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Python
self.__is_moving_up = False
self.__is_moving_down = False
self.__is_moving_left = False
self.__is_moving_right = False
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [moving_flags]: Flags de Movimiento Iniciados a *False*]

Ahora que se tiene una forma de relacionar una pulsación de una tecla con una acción específica del jugador, se sabe cuando hay que moverse arriba, abajo, izquierda o derecha. En este caso ya se puede empezar a escribir código en el método *update* del *main_loop*.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Python
def __update(self):
    movement = pygame.math.Vector2(0.0, 0.0)

    if self.__is_moving_up:
        movement.y -= 0.1
    if self.__is_moving_down:
        movement.y += 0.1
    if self.__is_moving_left:
        movement.x -= 0.1
    if self.__is_moving_right:
        movement.x += 0.1

    self.__hero_position += movement
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [update]: Método *update* Moviendo al Jugador]

Se verifica el estado de cada uno de los cuatro *flags*, y usando un *Vector2* se crea un vector de movimiento hacia donde se va a mover el jugador. No se usa una estructura *if elif* para dar cabida a que se pueda mover en varias direcciones a la vez, como las diagonales, y además se gestiona el caso de direcciones opuestas que se anularían.

Esto supone que hay que guardarse la posición del jugador en algún sitio, por ahora en el constructor de la clase se inicializa.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Python
self.__hero_position = pygame.math.Vector2(self.__window.get_width()/2 - self.__hero.get_width()/2, self.__window.get_height()/2 - self.__hero.get_height()/2)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [player_position]: Posición del Jugador]

Y a la hora de pintar el estado del juego se accede a esta variable para pintar la imagen del jugador en su posición actual.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Python
self.__window.blit(self.__hero, self.__hero_position.xy)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [player_render]: Pintar el Jugador]

Álgebra Vectorial
--------------------------------------------------------------

Los vectores son una parte importante del álgebra. Tienen muchas reglas y definiciones que no se van a tratar aquí. Sin embargo, son de uso muy extendido en videojuegos. En el módulo *math* de PyGame se encuentran las clases *Vector2* y *Vector3* para trabajar con véctores de 2 y 3 dimensiones. La documentación completa de estas clases se puede consultar en la [documentación oficial](https://www.pygame.org/docs/ref/math.html)

Una coordenada en un sistema cartesiano bidimensional necesita dos componentes *x* e *y*. Aunque los píxels en la pantalla sean número enteros es deseable que todas las posiciones, tamaños,... que se manejen dentro del juego se hagan con números reales para obtener mayor precisión en los cálculos y cuando se vaya a pintar se usarán los redondeos oportunos. Los objetos *Vector* que PyGame ofrece tienen las componentes necesarias encapsuladas y hacen que sea mucho más sencillo trabajar con posiciones, velocidades,... al poder hacer operaciones directamente sobre ellos y delegar en esas clases el trabajo por componentes.

Estos vectores se usaran no solo para definir posiciones, si no también orientaciones. Un vector es una estructura ideal para almacenar una coordenada bidimensional, en position absoluta o relativa, expresar una dirección a seguir o hacia donde disparar una bala. Si se habla de direcciones hay que trabajar con el concepto de normalización, vector unitario,... Estas operaciones aplican solo en direcciones, no en posiciones. Un vector normalizado es aquel que tiene longitud 1, o vector unitario, y el vector expresa la misma dirección que antes de ser normalizado.

En el caso del ejemplo anterior, un vector llamado *movement* expresa un movimiento desde el origen del sistema de coordenadas actual. Ese origen es la posición del jugador.

Movimiento Independiente de los Frames
--------------------------------------------------------------

Ejecutando el código anterior se puede observar que la imagen del jugador se mueve al pulsar las teclas, pero este movimiento se produce porque se le suma una cantidad fija al vector de movimiento en cada iteración del *main_loop*. Se ha definido el movimiento de una manera muy simplista, si el ordenador ejecuta la función *update* todo lo rápido que puede posiblemente llame a esta función varios cientos de veces por segundo, si se mueve la imagen del jugador 1 píxel en cada frame, esta velocidad es dependiente de cuantas veces se ejecute el *main_loop* por segundo, es decir, es dependiente del *frame rate*. Si este juego se ejecutara en otro ordenador con unas prestaciones diferentes este *frame rate* será distinto, y por tanto, también la velocidad a la que se mueve el jugador. Eso produce una experiencia de juego distinta en cada máquina distinta donde se ejecuta el juego, o incluso en distintos momentos en el mismo equipo en función de su carga de trabajo, y no es deseable.

Hay que conseguir que la velocidad a la que se mueve el jugador cambie en función del tiempo que cuesta cada frame. Hay una simple fórmula que puede funcionar.

\begin{equation}
distancia = velocidad * tiempo
\end{equation}

Con ella se puede calcular la velocidad relevante para cada frame, de manera que el jugador se mueva exactamente la distancia que se desea a lo largo de un segundo, sin importar la velocidad de la maquina donde se ejecuta.

Para ello se modifica el método *update* para que reciba como parámetro el tiempo que ha transcurrido desde el último frame, y con ello actualice la posición del jugador multiplicando este tiempo por la velocidad del jugador, calculando la distancia que se quiere mover en cada frame.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Python
def __update(self, delta_time):
    movement = pygame.math.Vector2(0.0, 0.0)

    if self.__is_moving_up:
        movement.y -= Game.__hero_speed
    if self.__is_moving_down:
        movement.y += Game.__hero_speed
    if self.__is_moving_left:
        movement.x -= Game.__hero_speed
    if self.__is_moving_right:
        movement.x += Game.__hero_speed

    self.__hero_position += movement * delta_time
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [update_delta]: Método *update* Usando Tiempo Delta]

Para calcular este tiempo que ha transcurrido entre dos frames se pueden usar las funciones del módulo *time* de PyGame. Se decide antes de nada a cuantos frames por segundo se quiere ejecutar el juego y se calcula cuanto tiempo se quiere dedicar a cada frame.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Python
__fps = 60
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [time_per_frame]: Cálculo del frame rate]

Concretamente la clase *Clock* y el método *tick*. Este método devuelve los milisegundos que han transcurrido desde la última vez que se llamó al método. Y además si se le pasa como parámetro los frames por segundo a los que se quiere ir, este método pausará la ejecución del juego para ajustar la velocidad y limitar el framerate.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Python
def run(self):
    self.__running = True

    fps_clock = pygame.time.Clock()
    while self.__running:
        delta_time = fps_clock.tick(Game.__fps)

        self.__process_events()
        self.__update(delta_time)
        self.__render()

    self.__quit()
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [main_loop_delta]: Método *main_loop* Usando Tiempo Delta]

Otras Técnicas
--------------------------------------------------------------

PyGame tiene dos funciones *wait* y *delay* para interrumpir la ejecución un tiempo determinado, lo cual le da al procesador una oportunidad de trabajar en otras tareas. Si se detecta en algún punto del juego que se puede liberar tiempo de procesado es interesante usarlo, sobre todo en dispositivos móviles, donde el uso razonable de la batería es importante.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Python
pygame.time.wait(50)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [time_delay]: Pausa el Juego durante 50 Milisegundos]

Otro parámetro importante es el llamado *v-sync*, o sincronización vertical. Esto adapta las llamadas al método *update* para sincronizarlas con la tasa de refresco del monitor, que suele ser de 60Hz. Se puede pasar como parámetro al método *set_mode* al crear la ventana, pero solo funciona para ventanas de *OpenGL*, y es muy dependiente del hardware y la configuración de los drivers del sistema, así que no es muy aconsejable usarla.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Python
self.__window = pygame.display.set_mode((640, 480), OPENGL, 32, vsync=1)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [ventana_vsync]: Ventana con *vsync*]

Frames Por Segundo
--------------------------------------------------------------

La forma habitual de medir el rendimiento de un juego, o la velocidad de refresco suele venir referida en *Frames Por Segundo*, *FPS*. Mientras se está desarrollando el juego es habitual poder visualizar esta velocidad para verificar que el juego se mueve dentro de los parámetros deseados.

Se puede crear una clase para ello, llamada *FPSStats*, que se encargue de gestionar la velocidad y pueda pintarla en pantalla visualizarla mientras se juega, y poder detectar posibles atascos o bajadas de rendimiento.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Python
class FPSStats:

    def __init__(self, font):
        self.__font = font
        self.__update_time = 0
        self.__frames = 0
        self.__set_fps_surface()
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [fpsstats_init]: Constructor de la Clase FPSStats]

Esta clase en el constructor recibirá como parámetro la fuente con la que se quiere pintar el texto con la velocidad. Y creará en su instancia una surface donde pintar el texto, y una serie de variables para gestionar los tiempos. En *frames* se irá acumulando las veces que se va a ejecutar el main loop en cada segundo, mientras que en *update_time* se va a guardar el tiempo transcurrido desde la última vez que se calculó la velocidad.

Publica una funció para que se actualice cada vez que se ejecuta el *main_loop*.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Python
def update(self, delta):
    self.__update_time += delta
    self.__frames += 1

    if self.__update_time >= 1000:
        self.__set_fps_surface()

        self.__update_time -= 1000
        self.__frames = 0
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [fpsstats_update]: Actualiza los Datos]

El método *update* se llamaría cada vez que se invoca el *main loop*, y además de acumular el número de llamadas, si se sobrepasa un tiempo determinado (en este caso 1 segundo), entonces se imprimen los datos en la *surface*, y se reinician los contadores.

En este caso, la velocidad del sistema, se mide por veces que se llama por segundo, lo que concuerda con el termino de *frames por segundo*.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Python
def __set_fps_surface(self):
    self.__fps = self.__font.render(f"{self.__frames} fps", True, (255,255,255), (0,0,0))

def render_stats(self, surface):
    surface.blit(self.__fps, (0,0))
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [fpsstats_render]: Renderiza los Datos]

El método *set_fps_surface* pinta sobre la surface interna los datos de *fps*, y el método *render_stats* pinta esa *surface* sobre la que recibe, en este caso para permitir al método *render* del *main loop* que se muestren dichos datos en el juego.

Clase Config
==============================================================

Cada vez que se introduce nueva funcionalidad en el juego, se suelen crear una serie de parámetros de ajuste para controlar dicha funcionalidad. En lugar de ir dejando esos parámetros repartidos a lo largo del código, se puede escribir una clase *Config* que los almacene en un sólo sitio. De esta manera, se tiene en un sólo sitio centralizado todos los parámetros de configuración del juego, y cambiar algunos comportamientos o la apariencia del juego es sencillo, solo hay que cambiar algunos valores en dicha clase.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Python
class Config:

    screen_size = (640, 480)
    game_title = "ShMUp"
    background_color = (0, 0, 0)

    def __init__(self):
        pass
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [config_class]: Clase *Config*]

Se pueden poner esos parámetros de configuración como miembros de clase estáticos, y que puedan ser accesibles públicamente desde cualquier punto del código.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Python
from shmup.config import Config

self.__window = pygame.display.set_mode(Config.screen_size, 0, 32)
pygame.display.set_caption(Config.game_title)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Listing [config_use]: Usar la clase *Config*]

Desde la clase *Game* se puede acceder a la clase *Config* y acceder a algunos parámetros, como por ejemplo, el tamaño de la ventana o el nombre del juego. De manera general, cualquier valor que se use durante el desarrollo del juego que pueda ser parametrizado debería acabar en la clase *Config*, y no declarado específicamente en el código que lo usa.

<link rel="stylesheet" href="res/md/viu.css">
<style class="fallback">body{visibility:hidden}</style><script>markdeepOptions={tocStyle:'long'};</script>
<!-- Markdeep: --><script src="res/md/markdeep.min.js?" charset="utf-8"></script>
